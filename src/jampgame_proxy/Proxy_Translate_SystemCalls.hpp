#pragma once

/*
===========================================================================
Copyright (C) 1999 - 2005, Id Software, Inc.
Copyright (C) 2000 - 2013, Raven Software, Inc.
Copyright (C) 2001 - 2013, Activision, Inc.
Copyright (C) 2005 - 2015, ioquake3 contributors
Copyright (C) 2013 - 2015, OpenJK contributors

This file is part of the OpenJK source code.

OpenJK is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License version 2 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, see <http://www.gnu.org/licenses/>.
===========================================================================
*/

#include <sdk/qcommon/qcommon.h>

int PASSFLOAT(float x);

void trap_Print(const char* fmt) ;
void trap_Error(const char* fmt);
int trap_Milliseconds(void);
void trap_PrecisionTimer_Start(void** theNewTimer);
int trap_PrecisionTimer_End(void* theTimer);
void trap_Cvar_Register(vmCvar_t* cvar, const char* var_name, const char* value, uint32_t flags);
void trap_Cvar_Update(vmCvar_t* cvar);
void trap_Cvar_Set(const char* var_name, const char* value);
int trap_Cvar_VariableIntegerValue(const char* var_name);
void trap_Cvar_VariableStringBuffer(const char* var_name, char* buffer, int bufsize);
int trap_Argc(void);
void trap_Argv(int n, char* buffer, int bufferLength);
int trap_FS_FOpenFile(const char* qpath, fileHandle_t* f, fsMode_t mode);
void trap_FS_Read(void* buffer, int len, fileHandle_t f);
void trap_FS_Write(const void* buffer, int len, fileHandle_t f);
void trap_FS_FCloseFile(fileHandle_t f);
void trap_SendConsoleCommand(int exec_when, const char* text);
void trap_LocateGameData(sharedEntity_t* gEnts, int numGEntities, int sizeofGEntity_t, playerState_t* clients, int sizeofGClient);
void trap_DropClient(int clientNum, const char* reason);
void trap_SendServerCommand(int clientNum, const char* text);
void trap_SetConfigstring(int num, const char* string);
void trap_GetConfigstring(int num, char* buffer, int bufferSize);
void trap_GetUserinfo(int num, char* buffer, int bufferSize);
void trap_SetUserinfo(int num, const char* buffer);
void trap_GetServerinfo(char* buffer, int bufferSize);
void trap_SetServerCull(float cullDistance);
void trap_SetBrushModel(sharedEntity_t* ent, const char* name);
void trap_Trace(trace_t* results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask);
void trap_G2Trace(trace_t* results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask, int g2TraceType, int traceLod);
int trap_PointContents(const vec3_t point, int passEntityNum);
qboolean trap_InPVS(const vec3_t p1, const vec3_t p2);
qboolean trap_InPVSIgnorePortals(const vec3_t p1, const vec3_t p2);
void trap_AdjustAreaPortalState(sharedEntity_t* ent, qboolean open);
qboolean trap_AreasConnected(int area1, int area2);
void trap_LinkEntity(sharedEntity_t* ent);
void trap_UnlinkEntity(sharedEntity_t* ent);
int trap_EntitiesInBox(const vec3_t mins, const vec3_t maxs, int* list, int maxcount);
qboolean trap_EntityContact(const vec3_t mins, const vec3_t maxs, const sharedEntity_t* ent);
int trap_BotAllocateClient(void);
void trap_BotFreeClient(int clientNum);
void trap_GetUsercmd(int clientNum, usercmd_t* cmd);
qboolean trap_GetEntityToken(char* buffer, int bufferSize);
void trap_SiegePersSet(siegePers_t* pers);
void trap_SiegePersGet(siegePers_t* pers);
int trap_FS_GetFileList(const char* path, const char* extension, char* listbuf, int bufsize);
int trap_DebugPolygonCreate(int color, int numPoints, vec3_t* points);
void trap_DebugPolygonDelete(int id);
int trap_RealTime(qtime_t* qtime);
void trap_SnapVector(float* v);
void trap_TraceCapsule(trace_t* results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask);
qboolean trap_EntityContactCapsule(const vec3_t mins, const vec3_t maxs, const sharedEntity_t* ent);
int trap_SP_GetStringTextString(const char* text, char* buffer, int bufferLength);
qboolean trap_ROFF_Clean(void);
void trap_ROFF_UpdateEntities(void);
int trap_ROFF_Cache(char* file);
qboolean trap_ROFF_Play(int entID, int roffID, qboolean doTranslation);
qboolean trap_ROFF_Purge_Ent(int entID);
void trap_TrueMalloc(void** ptr, int size);
void trap_TrueFree(void** ptr);
int trap_ICARUS_RunScript(sharedEntity_t* ent, const char* name);
qboolean trap_ICARUS_RegisterScript(const char* name, qboolean bCalledDuringInterrogate);
void trap_ICARUS_Init(void);
qboolean trap_ICARUS_ValidEnt(sharedEntity_t* ent);
qboolean trap_ICARUS_IsInitialized(int entID);
qboolean trap_ICARUS_MaintainTaskManager(int entID);
qboolean trap_ICARUS_IsRunning(int entID);
qboolean trap_ICARUS_TaskIDPending(sharedEntity_t* ent, int taskID);
void trap_ICARUS_InitEnt(sharedEntity_t* ent);
void trap_ICARUS_FreeEnt(sharedEntity_t* ent);
void trap_ICARUS_AssociateEnt(sharedEntity_t* ent);
void trap_ICARUS_Shutdown(void);
void trap_ICARUS_TaskIDSet(sharedEntity_t* ent, int taskType, int taskID);
void trap_ICARUS_TaskIDComplete(sharedEntity_t* ent, int taskType);
void trap_ICARUS_SetVar(int taskID, int entID, const char* type_name, const char* data);
int trap_ICARUS_VariableDeclared(const char* type_name);
int trap_ICARUS_GetFloatVariable(const char* name, float* value);
int trap_ICARUS_GetStringVariable(const char* name, const char* value);
int trap_ICARUS_GetVectorVariable(const char* name, const vec3_t value);
void trap_Nav_Init(void);
void trap_Nav_Free(void);
qboolean trap_Nav_Load(const char* filename, int checksum);
qboolean trap_Nav_Save(const char* filename, int checksum);
int trap_Nav_AddRawPoint(vec3_t point, int flags, int radius);
void trap_Nav_CalculatePaths(qboolean recalc);
void trap_Nav_HardConnect(int first, int second);
void trap_Nav_ShowNodes(void);
void trap_Nav_ShowEdges(void);
void trap_Nav_ShowPath(int start, int end);
int trap_Nav_GetNearestNode(sharedEntity_t* ent, int lastID, int flags, int targetID);
int trap_Nav_GetBestNode(int startID, int endID, int rejectID);
int trap_Nav_GetNodePosition(int nodeID, vec3_t out);
int trap_Nav_GetNodeNumEdges(int nodeID);
int trap_Nav_GetNodeEdge(int nodeID, int edge);
int trap_Nav_GetNumNodes(void);
qboolean trap_Nav_Connected(int startID, int endID);
int trap_Nav_GetPathCost(int startID, int endID);
int trap_Nav_GetEdgeCost(int startID, int endID);
int trap_Nav_GetProjectedNode(vec3_t origin, int nodeID);
void trap_Nav_CheckFailedNodes(sharedEntity_t* ent);
void trap_Nav_AddFailedNode(sharedEntity_t* ent, int nodeID);
qboolean trap_Nav_NodeFailed(sharedEntity_t* ent, int nodeID);
qboolean trap_Nav_NodesAreNeighbors(int startID, int endID);
void trap_Nav_ClearFailedEdge(failedEdge_t* failedEdge);
void trap_Nav_ClearAllFailedEdges(void);
int trap_Nav_EdgeFailed(int startID, int endID);
void trap_Nav_AddFailedEdge(int entID, int startID, int endID);
qboolean trap_Nav_CheckFailedEdge(failedEdge_t* failedEdge);
void trap_Nav_CheckAllFailedEdges(void);
qboolean trap_Nav_RouteBlocked(int startID, int testEdgeID, int endID, int rejectRank);
int trap_Nav_GetBestNodeAltRoute(int startID, int endID, int* pathCost, int rejectID);
int trap_Nav_GetBestNodeAltRoute2(int startID, int endID, int rejectID);
int trap_Nav_GetBestPathBetweenEnts(sharedEntity_t* ent, sharedEntity_t* goal, int flags);
int trap_Nav_GetNodeRadius(int nodeID);
void trap_Nav_CheckBlockedEdges(void);
void trap_Nav_ClearCheckedNodes(void);
int trap_Nav_CheckedNode(int wayPoint, int ent);
void trap_Nav_SetCheckedNode(int wayPoint, int ent, int value);
void trap_Nav_FlagAllNodes(int newFlag);
qboolean trap_Nav_GetPathsCalculated(void);
void trap_Nav_SetPathsCalculated(qboolean newVal);
void trap_SV_RegisterSharedMemory(char* memory);
int trap_BotLibSetup(void);
int trap_BotLibShutdown(void);
int trap_BotLibVarSet(char* var_name, char* value);
int trap_BotLibVarGet(char* var_name, char* value, int size);
int trap_BotLibDefine(char* string);
int trap_BotLibStartFrame(float time);
int trap_BotLibLoadMap(const char* mapname);
int trap_BotLibUpdateEntity(int ent, void* bue);
int trap_BotLibTest(int parm0, char* parm1, vec3_t parm2, vec3_t parm3);
int trap_BotGetSnapshotEntity(int clientNum, int sequence);
int trap_BotGetServerCommand(int clientNum, char* message, int size);
void trap_BotUserCommand(int clientNum, usercmd_t* ucmd);
void trap_AAS_EntityInfo(int entnum, void* info);
int trap_AAS_Initialized(void);
void trap_AAS_PresenceTypeBoundingBox(int presencetype, vec3_t mins, vec3_t maxs);
float trap_AAS_Time(void);
int trap_AAS_PointAreaNum(vec3_t point);
int trap_AAS_PointReachabilityAreaIndex(vec3_t point);
int trap_AAS_TraceAreas(vec3_t start, vec3_t end, int* areas, vec3_t* points, int maxareas);
int trap_AAS_BBoxAreas(vec3_t absmins, vec3_t absmaxs, int* areas, int maxareas);
int trap_AAS_AreaInfo(int areanum, void* info);
int trap_AAS_PointContents(vec3_t point);
int trap_AAS_NextBSPEntity(int ent);
int trap_AAS_ValueForBSPEpairKey(int ent, char* key, char* value, int size);
int trap_AAS_VectorForBSPEpairKey(int ent, char* key, vec3_t v);
int trap_AAS_FloatForBSPEpairKey(int ent, char* key, float* value);
int trap_AAS_IntForBSPEpairKey(int ent, char* key, int* value);
int trap_AAS_AreaReachability(int areanum);
int trap_AAS_AreaTravelTimeToGoalArea(int areanum, vec3_t origin, int goalareanum, int travelflags);
int trap_AAS_EnableRoutingArea(int areanum, int enable);
int trap_AAS_PredictRoute(void* route, int areanum, vec3_t origin, int goalareanum, int travelflags, int maxareas, int maxtime, int stopevent, int stopcontents, int stoptfl, int stopareanum);
int trap_AAS_AlternativeRouteGoals(vec3_t start, int startareanum, vec3_t goal, int goalareanum, int travelflags, void* altroutegoals, int maxaltroutegoals, int type);
int trap_AAS_Swimming(vec3_t origin);
int trap_AAS_PredictClientMovement(void* move, int entnum, vec3_t origin, int presencetype, int onground, vec3_t velocity, vec3_t cmdmove, int cmdframes, int maxframes, float frametime, int stopevent, int stopareanum, int visualize);
void trap_EA_Say(int client, char* str);
void trap_EA_SayTeam(int client, char* str);
void trap_EA_Command(int client, char* command);
void trap_EA_Action(int client, int action);
void trap_EA_Gesture(int client);
void trap_EA_Talk(int client);
void trap_EA_Attack(int client);
void trap_EA_Alt_Attack(int client);
void trap_EA_ForcePower(int client);
void trap_EA_Use(int client);
void trap_EA_Respawn(int client);
void trap_EA_Crouch(int client);
void trap_EA_MoveUp(int client);
void trap_EA_MoveDown(int client);
void trap_EA_MoveForward(int client);
void trap_EA_MoveBack(int client);
void trap_EA_MoveLeft(int client);
void trap_EA_MoveRight(int client);
void trap_EA_SelectWeapon(int client, int weapon);
void trap_EA_Jump(int client);
void trap_EA_DelayedJump(int client);
void trap_EA_Move(int client, vec3_t dir, float speed);
void trap_EA_View(int client, vec3_t viewangles);
void trap_EA_EndRegular(int client, float thinktime);
void trap_EA_GetInput(int client, float thinktime, void* input);
void trap_EA_ResetInput(int client);
int trap_BotLoadCharacter(char* charfile, float skill);
void trap_BotFreeCharacter(int character);
float trap_Characteristic_Float(int character, int index);
float trap_Characteristic_BFloat(int character, int index, float min, float max);
int trap_Characteristic_Integer(int character, int index);
int trap_Characteristic_BInteger(int character, int index, int min, int max);
void trap_Characteristic_String(int character, int index, char* buf, int size);
int trap_BotAllocChatState(void);
void trap_BotFreeChatState(int handle);
void trap_BotQueueConsoleMessage(int chatstate, int type, char* message);
void trap_BotRemoveConsoleMessage(int chatstate, int handle);
int trap_BotNextConsoleMessage(int chatstate, void* cm);
int trap_BotNumConsoleMessages(int chatstate);
void trap_BotInitialChat(int chatstate, char* type, int mcontext, char* var0, char* var1, char* var2, char* var3, char* var4, char* var5, char* var6, char* var7);
int trap_BotNumInitialChats(int chatstate, char* type);
int trap_BotReplyChat(int chatstate, char* message, int mcontext, int vcontext, char* var0, char* var1, char* var2, char* var3, char* var4, char* var5, char* var6, char* var7);
int trap_BotChatLength(int chatstate);
void trap_BotEnterChat(int chatstate, int client, int sendto);
void trap_BotGetChatMessage(int chatstate, char* buf, int size);
int trap_StringContains(char* str1, char* str2, int casesensitive);
int trap_BotFindMatch(char* str, void* match, unsigned long int context);
void trap_BotMatchVariable(void* match, int variable, char* buf, int size);
void trap_UnifyWhiteSpaces(char* string);
void trap_BotReplaceSynonyms(char* string, unsigned long int context);
int trap_BotLoadChatFile(int chatstate, char* chatfile, char* chatname);
void trap_BotSetChatGender(int chatstate, int gender);
void trap_BotSetChatName(int chatstate, char* name, int client);
void trap_BotResetGoalState(int goalstate);
void trap_BotResetAvoidGoals(int goalstate);
void trap_BotRemoveFromAvoidGoals(int goalstate, int number);
void trap_BotPushGoal(int goalstate, void* goal);
void trap_BotPopGoal(int goalstate);
void trap_BotEmptyGoalStack(int goalstate);
void trap_BotDumpAvoidGoals(int goalstate);
void trap_BotDumpGoalStack(int goalstate);
void trap_BotGoalName(int number, char* name, int size);
int trap_BotGetTopGoal(int goalstate, void* goal);
int trap_BotGetSecondGoal(int goalstate, void* goal);
int trap_BotChooseLTGItem(int goalstate, vec3_t origin, int* inventory, int travelflags);
int trap_BotChooseNBGItem(int goalstate, vec3_t origin, int* inventory, int travelflags, void* ltg, float maxtime);
int trap_BotTouchingGoal(vec3_t origin, void* goal);
int trap_BotItemGoalInVisButNotVisible(int viewer, vec3_t eye, vec3_t viewangles, void* goal);
int trap_BotGetLevelItemGoal(int index, char* classname, void* goal);
int trap_BotGetNextCampSpotGoal(int num, void* goal);
int trap_BotGetMapLocationGoal(char* name, void* goal);
float trap_BotAvoidGoalTime(int goalstate, int number);
void trap_BotSetAvoidGoalTime(int goalstate, int number, float avoidtime);
void trap_BotInitLevelItems(void);
void trap_BotUpdateEntityItems(void);
int trap_BotLoadItemWeights(int goalstate, char* filename);
void trap_BotFreeItemWeights(int goalstate);
void trap_BotInterbreedGoalFuzzyLogic(int parent1, int parent2, int child);
void trap_BotSaveGoalFuzzyLogic(int goalstate, char* filename);
void trap_BotMutateGoalFuzzyLogic(int goalstate, float range);
int trap_BotAllocGoalState(int state);
void trap_BotFreeGoalState(int handle);
void trap_BotResetMoveState(int movestate);
void trap_BotAddAvoidSpot(int movestate, vec3_t origin, float radius, int type);
void trap_BotMoveToGoal(void* result, int movestate, void* goal, int travelflags);
int trap_BotMoveInDirection(int movestate, vec3_t dir, float speed, int type);
void trap_BotResetAvoidReach(int movestate);
void trap_BotResetLastAvoidReach(int movestate);
int trap_BotReachabilityArea(vec3_t origin, int testground);
int trap_BotMovementViewTarget(int movestate, void* goal, int travelflags, float lookahead, vec3_t target);
int trap_BotPredictVisiblePosition(vec3_t origin, int areanum, void* goal, int travelflags, vec3_t target);
int trap_BotAllocMoveState(void);
void trap_BotFreeMoveState(int handle);
void trap_BotInitMoveState(int handle, void* initmove);
int trap_BotChooseBestFightWeapon(int weaponstate, int* inventory);
void trap_BotGetWeaponInfo(int weaponstate, int weapon, void* weaponinfo);
int trap_BotLoadWeaponWeights(int weaponstate, char* filename);
int trap_BotAllocWeaponState(void);
void trap_BotFreeWeaponState(int weaponstate);
void trap_BotResetWeaponState(int weaponstate);
int trap_GeneticParentsAndChildSelection(int numranks, float* ranks, int* parent1, int* parent2, int* child);
int trap_PC_LoadSource(const char* filename);
int trap_PC_FreeSource(int handle);
int trap_PC_ReadToken(int handle, pc_token_t* pc_token);
int trap_PC_SourceFileAndLine(int handle, char* filename, int* line);
qhandle_t trap_R_RegisterSkin(const char* name);
void trap_G2_ListModelBones(void* ghlInfo, int frame);
void trap_G2_ListModelSurfaces(void* ghlInfo);
qboolean trap_G2_HaveWeGhoul2Models(void* ghoul2);
void trap_G2_SetGhoul2ModelIndexes(void* ghoul2, qhandle_t* modelList, qhandle_t* skinList);
qboolean trap_G2API_GetBoltMatrix(void* ghoul2, const int modelIndex, const int boltIndex, mdxaBone_t* matrix, const vec3_t angles, const vec3_t position, const int frameNum, qhandle_t* modelList, vec3_t scale);
qboolean trap_G2API_GetBoltMatrix_NoReconstruct(void* ghoul2, const int modelIndex, const int boltIndex, mdxaBone_t* matrix, const vec3_t angles, const vec3_t position, const int frameNum, qhandle_t* modelList, vec3_t scale);
qboolean trap_G2API_GetBoltMatrix_NoRecNoRot(void* ghoul2, const int modelIndex, const int boltIndex, mdxaBone_t* matrix, const vec3_t angles, const vec3_t position, const int frameNum, qhandle_t* modelList, vec3_t scale);
int trap_G2API_InitGhoul2Model(void** ghoul2Ptr, const char* fileName, int modelIndex, qhandle_t customSkin, qhandle_t customShader, int modelFlags, int lodBias);
qboolean trap_G2API_SetSkin(void* ghoul2, int modelIndex, qhandle_t customSkin, qhandle_t renderSkin);
int trap_G2API_Ghoul2Size(void* ghlInfo);
int trap_G2API_AddBolt(void* ghoul2, int modelIndex, const char* boneName);
void trap_G2API_SetBoltInfo(void* ghoul2, int modelIndex, int boltInfo);
qboolean trap_G2API_SetBoneAngles(void* ghoul2, int modelIndex, const char* boneName, const vec3_t angles, const int flags, const int up, const int right, const int forward, qhandle_t* modelList, int blendTime, int currentTime);
qboolean trap_G2API_SetBoneAnim(void* ghoul2, const int modelIndex, const char* boneName, const int startFrame, const int endFrame, const int flags, const float animSpeed, const int currentTime, const float setFrame, const int blendTime);
qboolean trap_G2API_GetBoneAnim(void* ghoul2, const char* boneName, const int currentTime, float* currentFrame, int* startFrame, int* endFrame, int* flags, float* animSpeed, int* modelList, const int modelIndex);
void trap_G2API_GetGLAName(void* ghoul2, int modelIndex, char* fillBuf);
int trap_G2API_CopyGhoul2Instance(void* g2From, void* g2To, int modelIndex);
void trap_G2API_CopySpecificGhoul2Model(void* g2From, int modelFrom, void* g2To, int modelTo);
void trap_G2API_DuplicateGhoul2Instance(void* g2From, void** g2To);
qboolean trap_G2API_HasGhoul2ModelOnIndex(void* ghlInfo, int modelIndex);
qboolean trap_G2API_RemoveGhoul2Model(void* ghlInfo, int modelIndex);
qboolean trap_G2API_RemoveGhoul2Models(void* ghlInfo);
void trap_G2API_CleanGhoul2Models(void** ghoul2Ptr);
void trap_G2API_CollisionDetect(CollisionRecord_t* collRecMap, void* ghoul2, const vec3_t angles, const vec3_t position, int frameNumber, int entNum, vec3_t rayStart, vec3_t rayEnd, vec3_t scale, int traceFlags, int useLod, float fRadius);
void trap_G2API_CollisionDetectCache(CollisionRecord_t* collRecMap, void* ghoul2, const vec3_t angles, const vec3_t position, int frameNumber, int entNum, vec3_t rayStart, vec3_t rayEnd, vec3_t scale, int traceFlags, int useLod, float fRadius);
void trap_G2API_GetSurfaceName(void* ghoul2, int surfNumber, int modelIndex, char* fillBuf);
qboolean trap_G2API_SetRootSurface(void* ghoul2, const int modelIndex, const char* surfaceName);
qboolean trap_G2API_SetSurfaceOnOff(void* ghoul2, const char* surfaceName, const int flags);
qboolean trap_G2API_SetNewOrigin(void* ghoul2, const int boltIndex);
qboolean trap_G2API_DoesBoneExist(void* ghoul2, int modelIndex, const char* boneName);
int trap_G2API_GetSurfaceRenderStatus(void* ghoul2, const int modelIndex, const char* surfaceName);
void trap_G2API_AbsurdSmoothing(void* ghoul2, qboolean status);
void trap_G2API_SetRagDoll(void* ghoul2, sharedRagDollParams_t* params);
void trap_G2API_AnimateG2Models(void* ghoul2, int time, sharedRagDollUpdateParams_t* params);
qboolean trap_G2API_RagPCJConstraint(void* ghoul2, const char* boneName, vec3_t min, vec3_t max);
qboolean trap_G2API_RagPCJGradientSpeed(void* ghoul2, const char* boneName, const float speed);
qboolean trap_G2API_RagEffectorGoal(void* ghoul2, const char* boneName, vec3_t pos);
qboolean trap_G2API_GetRagBonePos(void* ghoul2, const char* boneName, vec3_t pos, vec3_t entAngles, vec3_t entPos, vec3_t entScale);
qboolean trap_G2API_RagEffectorKick(void* ghoul2, const char* boneName, vec3_t velocity);
qboolean trap_G2API_RagForceSolve(void* ghoul2, qboolean force);
qboolean trap_G2API_SetBoneIKState(void* ghoul2, int time, const char* boneName, int ikState, sharedSetBoneIKStateParams_t* params);
qboolean trap_G2API_IKMove(void* ghoul2, int time, sharedIKMoveParams_t* params);
qboolean trap_G2API_RemoveBone(void* ghoul2, const char* boneName, int modelIndex);
void trap_G2API_AttachInstanceToEntNum(void* ghoul2, int entityNum, qboolean serverb);
void trap_G2API_ClearAttachedInstance(int entityNum);
void trap_G2API_CleanEntAttachments(void);
qboolean trap_G2API_OverrideServer(void* serverInstance);
const char* trap_SetActiveSubBSP(int index);
int trap_CM_RegisterTerrain(const char* config);
void trap_RMG_Init(void);
void trap_Bot_UpdateWaypoints(int wpnum, wpobject_t** wps);
void trap_Bot_CalculatePaths(int rmg);
int SVSyscall_FS_Read(void* buffer, int len, fileHandle_t f);
int SVSyscall_FS_Write(const void* buffer, int len, fileHandle_t f);
qboolean SVSyscall_EntityContact(const vec3_t mins, const vec3_t maxs, const sharedEntity_t* ent, int capsule);
void SVSyscall_Trace(trace_t* results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask, int capsule, int traceFlags, int useLod);
